"""
AquaBrain Skill Factory V2.0
============================
LLM-powered skill generation - "The System Builds Itself"

This service generates new skill Python files from natural language descriptions.
Uses Claude (or any LLM) to write code that conforms to the AquaSkill interface.

Features:
- Natural language -> Python skill generation
- Template-based code structure
- Automatic validation and testing
- Hot-reload into registry
- Prompt governance for safety
"""

from __future__ import annotations
from typing import Dict, Any, Optional, List
from datetime import datetime
from pathlib import Path
import json
import uuid
import re
import ast
import traceback

# Optional: Use Anthropic Claude for generation
try:
    import anthropic
    HAS_ANTHROPIC = True
except ImportError:
    HAS_ANTHROPIC = False

from skills.base import (
    AquaSkill,
    SkillMetadata,
    InputSchema,
    InputField,
    FieldType,
    SkillCategory,
    ExecutionResult,
    ExecutionStatus,
    skill_registry,
    register_skill,
)


# ============================================================================
# SKILL CODE TEMPLATE
# ============================================================================

SKILL_TEMPLATE = '''"""
{description}
Auto-generated by AquaBrain Skill Factory
Generated: {timestamp}
"""

from skills.base import (
    AquaSkill,
    SkillMetadata,
    InputSchema,
    InputField,
    FieldType,
    SkillCategory,
    ExecutionResult,
    ExecutionStatus,
    register_skill,
)
from typing import Dict, Any


@register_skill
class {class_name}(AquaSkill):
    """
    {docstring}
    """

    @property
    def metadata(self) -> SkillMetadata:
        return SkillMetadata(
            id="{skill_id}",
            name="{name}",
            description="{description}",
            category=SkillCategory.{category},
            icon="{icon}",
            color="{color}",
            version="1.0.0",
            author="Skill Factory",
            tags={tags},
        )

    @property
    def input_schema(self) -> InputSchema:
        return InputSchema(fields=[
{fields}
        ])

    def execute(self, inputs: Dict[str, Any]) -> ExecutionResult:
        """Execute the skill logic."""
        try:
{execute_code}

            return ExecutionResult(
                status=ExecutionStatus.SUCCESS,
                skill_id=self.metadata.id,
                message="Execution completed successfully",
                output=result,
            )

        except Exception as e:
            return ExecutionResult(
                status=ExecutionStatus.FAILED,
                skill_id=self.metadata.id,
                message="Execution failed",
                error=str(e),
            )
'''

# ============================================================================
# LLM PROMPT FOR SKILL GENERATION
# ============================================================================

LLM_SYSTEM_PROMPT = """You are an expert Python developer creating AquaBrain skills.

AquaBrain is an MEP (Mechanical, Electrical, Plumbing) engineering automation platform.
Skills are modular units of functionality that can be triggered via API.

Your task is to generate Python code that:
1. Follows the AquaSkill interface exactly
2. Includes proper input validation
3. Handles errors gracefully
4. Returns results in the expected format

IMPORTANT RULES:
- Use only standard library + pydantic (no external dependencies unless specified)
- Always validate inputs before processing
- Never use eval() or exec() on user input
- Include helpful error messages
- Use descriptive variable names

Output JSON with these fields:
{
    "name": "Human readable name",
    "description": "What this skill does",
    "category": "One of: revit, autocad, hydraulics, documentation, file_processing, data_analysis, reporting, integration, custom",
    "icon": "Lucide icon name",
    "color": "#hex color",
    "tags": ["tag1", "tag2"],
    "fields": [
        {
            "name": "field_name",
            "label": "Display Label",
            "type": "text|number|select|boolean|file|date|textarea|json",
            "required": true,
            "default": null,
            "description": "Help text",
            "options": [{"value": "v1", "label": "Label 1"}]  // for select type
        }
    ],
    "execute_code": "Python code for the execute method body (indented correctly)"
}
"""

LLM_USER_PROMPT_TEMPLATE = """Create an AquaBrain skill based on this description:

{user_description}

The skill should:
- Accept the necessary inputs
- Perform the described operation
- Return meaningful output

Generate the JSON specification for this skill.
"""


# ============================================================================
# SKILL FACTORY
# ============================================================================

class SkillFactory:
    """
    LLM-powered skill generation factory.

    The heart of "The System Builds Itself" - converts natural language
    descriptions into functional AquaBrain skills.
    """

    def __init__(
        self,
        output_dir: Optional[Path] = None,
        anthropic_api_key: Optional[str] = None,
    ):
        """
        Initialize the factory.

        Args:
            output_dir: Directory for generated skill files
            anthropic_api_key: API key for Claude (optional)
        """
        if output_dir is None:
            output_dir = Path(__file__).parent.parent / "skills" / "custom"
        self.output_dir = output_dir
        self.output_dir.mkdir(parents=True, exist_ok=True)

        self.anthropic_client = None
        if HAS_ANTHROPIC and anthropic_api_key:
            self.anthropic_client = anthropic.Anthropic(api_key=anthropic_api_key)

        # Track generated skills
        self.generated_skills: List[Dict[str, Any]] = []

    def generate_from_description(
        self,
        description: str,
        use_llm: bool = True,
    ) -> Dict[str, Any]:
        """
        Generate a skill from a natural language description.

        Args:
            description: What the skill should do
            use_llm: Whether to use LLM for generation (requires API key)

        Returns:
            Dict with skill_id, file_path, and metadata
        """
        if use_llm and self.anthropic_client:
            spec = self._generate_with_llm(description)
        else:
            spec = self._generate_template_skill(description)

        # Generate Python code
        code = self._build_skill_code(spec)

        # Validate syntax
        if not self._validate_python_syntax(code):
            raise ValueError("Generated code has syntax errors")

        # Save to file
        skill_id = spec.get("skill_id", f"custom_{uuid.uuid4().hex[:8]}")
        filename = f"{skill_id}.py"
        filepath = self.output_dir / filename

        with open(filepath, "w", encoding="utf-8") as f:
            f.write(code)

        # Hot-reload into registry
        self._hot_reload_skill(skill_id, filepath)

        result = {
            "skill_id": skill_id,
            "file_path": str(filepath),
            "name": spec.get("name"),
            "description": spec.get("description"),
            "category": spec.get("category"),
            "icon": spec.get("icon"),
            "color": spec.get("color"),
            "fields_count": len(spec.get("fields", [])),
            "generated_at": datetime.utcnow().isoformat(),
        }

        self.generated_skills.append(result)
        return result

    def _generate_with_llm(self, description: str) -> Dict[str, Any]:
        """Use Claude to generate skill specification."""
        if not self.anthropic_client:
            raise RuntimeError("Anthropic client not configured")

        response = self.anthropic_client.messages.create(
            model="claude-sonnet-4-20250514",
            max_tokens=4096,
            system=LLM_SYSTEM_PROMPT,
            messages=[
                {
                    "role": "user",
                    "content": LLM_USER_PROMPT_TEMPLATE.format(user_description=description)
                }
            ]
        )

        # Extract JSON from response
        content = response.content[0].text
        json_match = re.search(r'\{[\s\S]*\}', content)
        if not json_match:
            raise ValueError("LLM did not return valid JSON")

        spec = json.loads(json_match.group())
        spec["skill_id"] = f"custom_{uuid.uuid4().hex[:8]}"
        return spec

    def _generate_template_skill(self, description: str) -> Dict[str, Any]:
        """
        Generate a basic skill spec without LLM.

        Creates a simple skill based on keyword analysis.
        """
        skill_id = f"custom_{uuid.uuid4().hex[:8]}"

        # Analyze description for category hints
        desc_lower = description.lower()
        category = "custom"
        icon = "Cog"
        color = "#BD00FF"

        if any(word in desc_lower for word in ["calculate", "math", "formula"]):
            category = "data_analysis"
            icon = "Calculator"
            color = "#4FACFE"
        elif any(word in desc_lower for word in ["report", "document", "pdf"]):
            category = "reporting"
            icon = "FileText"
            color = "#00E676"
        elif any(word in desc_lower for word in ["revit", "model", "bim"]):
            category = "revit"
            icon = "Building2"
            color = "#FF6B35"
        elif any(word in desc_lower for word in ["pipe", "hydraulic", "flow"]):
            category = "hydraulics"
            icon = "Droplets"
            color = "#00BFFF"

        # Create basic input field
        name = description[:50] if len(description) > 50 else description
        name = re.sub(r'[^a-zA-Z0-9\s]', '', name).strip().title()

        return {
            "skill_id": skill_id,
            "name": name,
            "description": description,
            "category": category,
            "icon": icon,
            "color": color,
            "tags": ["auto-generated", "custom"],
            "fields": [
                {
                    "name": "input_data",
                    "label": "Input Data",
                    "type": "textarea",
                    "required": True,
                    "description": "Enter your input data"
                }
            ],
            "execute_code": """# Basic implementation - customize as needed
input_data = inputs.get("input_data", "")

# Process the input
result = {
    "processed": True,
    "input_length": len(input_data),
    "message": "Processed input successfully"
}"""
        }

    def _build_skill_code(self, spec: Dict[str, Any]) -> str:
        """Build Python code from specification."""
        # Convert class name
        class_name = re.sub(r'[^a-zA-Z0-9]', '', spec.get("name", "CustomSkill"))
        class_name = class_name + "Skill" if not class_name.endswith("Skill") else class_name

        # Build fields code
        fields_code = []
        for field in spec.get("fields", []):
            field_type = field.get("type", "text").upper()
            if field_type not in [ft.value.upper() for ft in FieldType]:
                field_type = "TEXT"

            field_code = f'''            InputField(
                name="{field.get('name', 'input')}",
                label="{field.get('label', 'Input')}",
                type=FieldType.{field_type},
                required={field.get('required', True)},'''

            if field.get("default") is not None:
                field_code += f'\n                default={repr(field["default"])},'
            if field.get("description"):
                field_code += f'\n                description="{field["description"]}",'
            if field.get("options"):
                options_str = json.dumps(field["options"])
                field_code += f'\n                options={options_str},'

            field_code += '\n            ),'
            fields_code.append(field_code)

        # Build execute code (ensure proper indentation)
        execute_code = spec.get("execute_code", '''            result = {"status": "ok"}''')
        if not execute_code.strip().startswith(" "):
            execute_code = "            " + execute_code.replace("\n", "\n            ")

        return SKILL_TEMPLATE.format(
            class_name=class_name,
            skill_id=spec.get("skill_id", "custom_skill"),
            name=spec.get("name", "Custom Skill"),
            description=spec.get("description", "Auto-generated skill"),
            docstring=spec.get("description", "Auto-generated skill"),
            category=spec.get("category", "custom").upper(),
            icon=spec.get("icon", "Cog"),
            color=spec.get("color", "#BD00FF"),
            tags=repr(spec.get("tags", ["custom"])),
            fields="\n".join(fields_code),
            execute_code=execute_code,
            timestamp=datetime.utcnow().isoformat(),
        )

    def _validate_python_syntax(self, code: str) -> bool:
        """Validate Python syntax."""
        try:
            ast.parse(code)
            return True
        except SyntaxError as e:
            print(f"[ERROR] Syntax error in generated code: {e}")
            return False

    def _hot_reload_skill(self, skill_id: str, filepath: Path) -> bool:
        """Hot-reload a skill into the registry."""
        try:
            import importlib.util

            spec = importlib.util.spec_from_file_location(skill_id, filepath)
            if spec and spec.loader:
                module = importlib.util.module_from_spec(spec)
                spec.loader.exec_module(module)
                return True
        except Exception as e:
            print(f"[ERROR] Failed to hot-reload skill {skill_id}: {e}")
            return False

    def list_custom_skills(self) -> List[Dict[str, Any]]:
        """List all custom skills in the output directory."""
        skills = []
        for filepath in self.output_dir.glob("*.py"):
            if filepath.name.startswith("_"):
                continue
            skills.append({
                "filename": filepath.name,
                "skill_id": filepath.stem,
                "path": str(filepath),
                "size_bytes": filepath.stat().st_size,
                "modified": datetime.fromtimestamp(filepath.stat().st_mtime).isoformat(),
            })
        return skills

    def delete_custom_skill(self, skill_id: str) -> bool:
        """Delete a custom skill file and unregister it."""
        filepath = self.output_dir / f"{skill_id}.py"
        if filepath.exists():
            filepath.unlink()
            skill_registry.unregister(skill_id)
            return True
        return False


# ============================================================================
# FACTORY API INTEGRATION
# ============================================================================

# Global factory instance
_factory: Optional[SkillFactory] = None


def get_factory() -> SkillFactory:
    """Get or create the global factory instance."""
    global _factory
    if _factory is None:
        import os
        api_key = os.environ.get("ANTHROPIC_API_KEY")
        _factory = SkillFactory(anthropic_api_key=api_key)
    return _factory


def generate_skill(description: str, use_llm: bool = False) -> Dict[str, Any]:
    """
    Generate a new skill from description.

    Convenience function for API use.
    """
    factory = get_factory()
    return factory.generate_from_description(description, use_llm=use_llm)
